## Работа с аппаратными интерфейсами: I²C, Serial и другие низкоуровневые устройства

В VRack2 часто требуется взаимодействовать с физическими устройствами через интерфейсы, такие как **I²C**, **UART (Serial)**, **SPI** или **GPIO**. Однако эти интерфейсы имеют особенности, которые важно учитывать при разработке сервисов.

### Почему это не так просто?

Библиотеки вроде `i2c-bus` или `serialport` обычно содержат нативные аддоны, скомпилированные под конкретную версию Node.js. Кроме того, многие из них **не поддерживают многоконтекстную загрузку**, что делает их **несовместимыми с `worker_threads`** - механизмом, который VRack2 использует для запуска сервисов.

Если попытаться импортировать такие модули внутри Worker’а, вы получите ошибку вида:

```
Error: Module did not self-register: '.../i2c.node'
```

Это не ошибка VRack2 и не проблема установки - это ограничение самих нативных модулей.

### Как правильно работать с такими устройствами в VRack2?

VRack2 предлагает два проверенных подхода.

#### 1. Использовать изоляцию

По умолчанию VRack2 запускает сервисы как потоки (`worker_threads`). Но можно указать, чтобы сервис запускался в отдельном процессе. Это полностью изолирует код от основного потока и позволяет использовать нативные библиотеки.

Для этого добавьте в метаинформацию сервиса параметр `"isolated": true`, например:

```json
{
    "name": "Test internal uart",
    "group": "сервисы",
    "autoStart": true,
    "autoReload": true,
    "isolated": true,
    "description": "Test"
}
```

Изолированный процесс работает **точно так же**, как и поток. Разница - только в потреблении памяти и времени запуска:  
- Потоки используют уже запущенный экземпляр Node.js.  
- Изолированный процесс запускает собственный экземпляр Node.js, что немного увеличивает потребление памяти.

#### 2. VGranite - внешний сервис-транслятор

[VGranite](https://github.com/VRack2/vgranite) - это лёгкое приложение, которое создаёт **сетевые туннели** между TCP/Socket и физическими последовательными портами (Serial).

Как это работает:
- VGranite запускается **отдельным процессом** на той же машине, где работает VRack2.
- Он открывает, например, `/dev/ttyUSB0` и слушает TCP-порт (например, `localhost:8081`).
- Любое приложение, включая VRack2-устройства, может подключиться к этому порту как к обычному сокету и обмениваться данными.

Преимущества:
- Полная изоляция от нативных модулей в VRack2.
- Возможность использовать Serial даже из Worker’ов (через стандартные модули `net`).
- Простота развёртывания и отладки.

> VGranite особенно удобен, если вы хотите **абстрагироваться от физического уровня** и работать с устройством как с сетевым сервисом.

Однако VGranite **не поддерживает шины вроде I²C или SPI** - по крайней мере, на текущий момент.
Вот переработанный и стилистически выровненный вариант текста - он стал чище, логичнее и легче читается, но сохранил техническую точность:

## Что выбрать? как работать?

У каждого подхода есть свои плюсы и минусы.

**Для быстрого прототипирования** удобнее подключаться к шине напрямую из вашего устройства. Это позволяет быстро проверить логику, протокол и поведение без дополнительной инфраструктуры.

Однако в готовом решении лучше вынести работу с шиной в **отдельное устройство**, которое будет предоставлять доступ к ней другим компонентам VRack2. 

### Почему нельзя просто работать с шиной?

На одной физической шине (например, I²C или RS-485/Modbus RTU) может находиться несколько устройств, но **одновременно общаться можно только с одним**. Хотя протоколы поддерживают адресацию (устройства выбираются по уникальному адресу), сама шина требует **последовательного доступа** - одновременные запросы вызовут конфликты и нарушат обмен.

Поэтому в VRack2 каждое виртуальное устройство должно взаимодействовать с шиной **по очереди**.

### Как это реализовано в `ConverterBus` из `vrack2-net`

`ConverterBus` - это устройство, которое подключается к **сетевому туннелю** (например, созданному VGranite или другим Ethernet ↔ Serial-преобразователем) и предоставляет **мультиплексированный доступ** к одной логической шине для нескольких виртуальных устройств в VRack2.

Таким образом, `ConverterBus` работает не с физическим портом напрямую, а через **сокет-интерфейс**, абстрагируя сетевой уровень и позволяя нескольким потребителям безопасно взаимодействовать с шиной по очереди.

#### Как это работает

`ConverterBus` создаёт несколько виртуальных выходов: `dev1`, `dev2`, ..., `devN`. При запуске он анализирует, какие из этих выходов подключены к устройствам, и строит внутреннюю таблицу активных портов.

Пример логики настройки (из исходного кода):

```ts
/**
 * Заполняет shares данными на основе реально подключённых портов.
 * Вызывается только внутри this.process().
 */
protected fillSharesPorts() {
  for (let i = 1; i <= this.options.devices; i++) {
    const port = this.portName(i); // Например, "dev1"

    // Если порт не подключён - помечаем как неактивный
    if (!this.ports.output[port].connected) {
      this.shares.deviceList[port] = false;
      this.shares.ports[i] = false;
      continue;
    }

    // На один выход должно быть ровно одно соединение
    if (this.ports.output[port].connections.length > 1) {
      throw ErrorManager.make('V2NET_CONN_MORE_ONE');
    }

    // Сохраняем имя активного порта
    this.shares.ports[i] = port;

    // Получаем информацию об устройстве на другом конце
    const connection = this.ports.output[port].connections[0];
    const dInfo = {
      id: connection.inputLink.Device.id,
      type: connection.inputLink.Device.type,
    };

    this.shares.deviceList[port] = dInfo;
  }
}
```

После определения активных портов `ConverterBus` подключается к физической шине. Если подключение успешно, он **поочерёдно** передаёт каждому подключённому устройству специальный **провайдер доступа** к шине - объект, через который можно выполнять нужные операции с шиной.

Таким образом, несколько виртуальных устройств могут **разделять одну физическую шину**, не мешая друг другу.

Подробнее в [официальной документации `ConverterBus`](https://github.com/VRack2/vrack2-net/blob/main/docs/ConverterBus.md).

У прямого доступа к шине есть ещё одна существенная проблема: **невозможно работать с ней удалённо**.  

Если же вы создадите абстракцию над шиной и оформите её как отдельное устройство, то сможете взаимодействовать с шиной **через сеть**, как будто она локальная.

Да, это реально: определите единый интерфейс провайдера для I²C (или любого другого протокола) и реализуйте его сетевую версию - и вы получите **прозрачный доступ** к шине, будь она подключена локально или находится на удалённой машине.

Такой подход даёт гораздо больше гибкости, хотя и требует дополнительных архитектурных и инфраструктурных усилий. Зато вы можете запускать такие абстракции в **отдельных изолированных процессах** внутри VRack2. А если шина «зависнет» или драйвер поведёт себя нестабильно - достаточно перезапустить только этот процесс, **не затрагивая основной сервис**.

### Что выбрать? Рекомендации по сценариям

- **Для быстрого прототипирования** - работайте с шиной напрямую. Это проще и быстрее, но подходит только для локальной узконаправленной разработки.  
- **Для надёжного локального решения** - вынесите управление шиной в отдельное устройство (по примеру `ConverterBus`). Это обеспечит корректный доступ нескольких потребителей.
- **Для гибкости и масштабируемости** - используйте сетевой доступ к шине (через VGranite или собственную абстракцию). Такой подход позволяет работать с оборудованием удалённо, изолировать драйверы и легко перезапускать компоненты без остановки всей системы.
